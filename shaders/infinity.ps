#ifdef GL_ES
precision mediump float;
#endif

uniform vec4 TIMEPARAMS;
uniform sampler2D SAMPLER[3]; // textura base
varying vec2 PS_TEXCOORD0;

vec3 hsv2rgb(vec3 c) {
    vec3 rgb = clamp(
        abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0),
                6.0) - 3.0) - 1.0,
        0.0,
        1.0);
    rgb = rgb * rgb * (3.0 - 2.0 * rgb);
    return c.z * mix(vec3(1.0), rgb, c.y);
}

#define SRC_IMAGE SAMPLER[0]
#define MASKED_SAMPLER SAMPLER[1]
#define EFFECT_SAMPLER SAMPLER[2]

void main() {
    vec3 baseColor = texture2D(EFFECT_SAMPLER, PS_TEXCOORD0).rgb;

    // Definimos el color "blanco/gris" que quieres detectar
    vec3 targetColor = vec3(0.78); // hsv(0,0,0.78) → rgb(0.78,0.78,0.78)

    // Tolerancia para comparar colores
    float tolerance = 0.02;
    float diff = distance(baseColor, targetColor);

    if (diff < tolerance) {
        // Si coincide con el color, aplicamos el ciclo arcoíris
        float hue = mod(TIMEPARAMS.x * 0.1, 1.0);
        vec3 rainbow = hsv2rgb(vec3(hue, 1.0, 1.0));
        gl_FragColor = vec4(rainbow, 1.0);
    } else {
        // Si no coincide, dejamos el color original
        gl_FragColor = vec4(baseColor, 1.0);
    }
}